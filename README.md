# base
##冒泡算法(bubbleSort.js)
>   冒泡排序的基本思想：所谓冒泡就是泡泡一个一个往上冒，让体积最轻的泡泡浮在最上面，然后按照重量往下依次排列。
var a=[12,3,43,11,56,90,7,66,82];
拿上面的数组a举例，做一个升序排序。第一轮循环我们得把值最大的数从数组中找出来放在数组最后，即索引为a.length-1的位置。也就是从a[0]开始，依次往后比较相邻两个数的大小。
首先是a[0]和a[1]比较，如果a[0]>a[1]，则交换两个数的位置，反之则不交换。a[0]是12，a[1]是3，所以得交换位置，交换完位置之后的数组是[3,12,43,11,56,90,7,66,82]，
然后比较a[1]和a[2],(a[1]=12)< (a[2]=43),不用交换位置，同理往后比较a[2]和a[3]，(a[2]=43)>(a[3]=11),
交换位置，此时的数组a为[3,12,11,43,56,90,7,66,82]，以此类推，如果a[j]>a[j+1]就交换值，否则，继续往后。
注意：两个变量交换数据，一般情况下需要一个中介变量。比如：var a="a",b="b";让a和b交换值，需要一个中介变量：var temp=a;a=b;b=temp；这样
第一轮外层循环完之后，我们得到的数组a为[3,12,11,43,56,7,66,82,90]，把值最大的90放在了数组的末尾。
第二次外层循环，我们只需要比较到a.length-2的位置即可，因为最后一项a[a.length-1]已经确定了（90）.
第三次外层循环，我们需要比较到a.length-3的位置，所以内重循环j的值为j< a.length-1-i,通过两重循环，冒泡排序就完成了。

##快速排序(quickSort.js)
>   快速排序的基本思想：首先从数组a中选取一个基准点（通常我们取中间项作为基准点），然后遍历数组，把小于基准点的项放到基准点左边集合，把大于基准点的项放到基准点右边集合。
再对左边和右边两个集合重复前面的操作，直到每个子集就剩下一个元素。其实就是一个递归的思想。
 依旧拿数组a=[12,3,43,11,56,90,7,66,82]举例，我们先选取一个基准点pivot=a[Math.floor(a.length/2)]，即a[4]值为56，
 然后便利数组中的剩余项，把小于56的数组项放在左边的数组left中，把大于等于56的数组项放在右边的数组right中，第一轮操作结束后left=[12,3,43,11,7]，right=[90,66,82]，然后再对left和right重复以上的操作，直到left和right仅剩一项或为空时结束。最后返回left+pivot+right。

##前插排序(insertSort.js)
>   排序的基本思想：首先选取数组的第一项即a[0]，我们可以认为这个数是已经排好序的，
再取a[1]项插入到已经排好序的元素中，此时只有a[0]，所以我们需要比较a[1]和a[0]的大小。
如果a[1]<a[0]，则需要把a[1]先用一个临时变量temp保存，a[0]往后挪一位（即a[1]的位置），然后把temp赋值给a[0]。
要插入的元素依次为a[1]-a[a.length-1]项，插入每一项时，都需要从后往前遍历已排好序的元素，如果已排好序的元素比要插入的元素大，则把该元素往后挪一位，直到已排好的元素小于等于要插入的元素（或者已经遍历完了已排好序的数组项），则把要插入的元素放入该位置+1的索引中（或者放在数组的第0个位置）。对每个插入项都执行上面的操作，则最后的数组就排好序了。